from fastapi import APIRouter, HTTPException, Depends, Request
import requests
from typing import List, Optional
from psycopg2.extras import RealDictCursor

from routers.auth import verify_token
from core.rate_limiting import limiter, cve_search_limit
from database.connection import get_db_connection

router = APIRouter()

@router.get("/search")
async def search_exploits(
    query: str,
    exploit_type: Optional[str] = None,
    platform: Optional[str] = None,
    limit: int = 50,
    user_data: dict = Depends(verify_token),
    http_request: Request = None
):
    try:
        local_exploits = search_local_exploits(query, exploit_type, platform, limit)
        
        if len(local_exploits) < limit:
            try:
                online_exploits = search_online_exploits(query, limit - len(local_exploits))
                local_exploits.extend(online_exploits)
            except Exception as e:
                # Continue even if online search fails
                pass
        
        # Add CVE information to each exploit
        for exploit in local_exploits:
            if exploit.get('cve_id'):
                exploit['cve_link'] = f"https://nvd.nist.gov/vuln/detail/{exploit['cve_id']}"
                if exploit.get('edb_id'):
                    exploit['exploitdb_link'] = f"https://www.exploit-db.com/exploits/{exploit.get('edb_id', '').replace('EDB-', '')}"
        
        return {"exploits": local_exploits[:limit], "total": len(local_exploits)}
    except Exception as e:
        # Return empty results rather than failing completely
        return {"exploits": [], "total": 0, "error": str(e)}

@router.get("/by-cve/{cve_id}")
async def get_exploits_by_cve(
    cve_id: str,
    user_data: dict = Depends(verify_token)
):
    """Get all exploits for a specific CVE"""
    with get_db_connection() as conn:
        cursor = conn.cursor(cursor_factory=RealDictCursor)
        cursor.execute("""
            SELECT edb_id, title, description, exploit_type, platform, 
                   author, published_date, cve_id, code
            FROM exploits 
            WHERE cve_id = %s
            ORDER BY published_date DESC
        """, (cve_id,))
        results = cursor.fetchall()
        cursor.close()
        
        exploits = [dict(r) for r in results]
        for exploit in exploits:
            exploit['exploitdb_link'] = f"https://www.exploit-db.com/exploits/{exploit.get('edb_id', '').replace('EDB-', '')}"
        
        return {"cve_id": cve_id, "exploits": exploits, "total": len(exploits)}

@router.get("/details/{exploit_id}")
async def get_exploit_details(
    exploit_id: str,
    user_data: dict = Depends(verify_token)
):
    with get_db_connection() as conn:
        cursor = conn.cursor(cursor_factory=RealDictCursor)
        cursor.execute("SELECT * FROM exploits WHERE exploit_id = %s", (exploit_id,))
        result = cursor.fetchone()
        cursor.close()
        
        if not result:
            raise HTTPException(status_code=404, detail="Exploit not found")
        
        return dict(result)

def search_local_exploits(query: str, exploit_type: Optional[str], platform: Optional[str], limit: int):
    try:
        with get_db_connection() as conn:
            cursor = conn.cursor(cursor_factory=RealDictCursor)
            
            sql = "SELECT * FROM exploits WHERE title ILIKE %s OR description ILIKE %s"
            params = [f"%{query}%", f"%{query}%"]
            
            if exploit_type:
                sql += " AND type = %s"
                params.append(exploit_type)
            
            if platform:
                sql += " AND platform ILIKE %s"
                params.append(f"%{platform}%")
            
            sql += " ORDER BY date_published DESC LIMIT %s"
            params.append(limit)
            
            cursor.execute(sql, params)
            results = cursor.fetchall()
            cursor.close()
            
            return [dict(result) for result in results]
    except Exception as e:
        # Return empty list if database query fails
        return []

def search_online_exploits(query: str, limit: int):
    exploits = []
    
    try:
        nvd_exploits = search_nvd_exploits(query, limit)
        exploits.extend(nvd_exploits)
    except Exception:
        pass
    
    return exploits[:limit]

def search_nvd_exploits(query: str, limit: int):
    exploits = []
    
    try:
        nvd_api = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        params = {
            "keywordSearch": query,
            "resultsPerPage": min(limit, 20)
        }
        
        response = requests.get(nvd_api, params=params, timeout=10)
        response.raise_for_status()
        
        data = response.json()
        
        for cve_item in data.get('vulnerabilities', [])[:limit]:
            cve = cve_item.get('cve', {})
            cve_id = cve.get('id', 'Unknown')
            
            descriptions = cve.get('descriptions', [])
            description = descriptions[0].get('value', 'No description') if descriptions else 'No description'
            
            exploits.append({
                "exploit_id": cve_id,
                "title": f"CVE Vulnerability: {cve_id}",
                "description": description[:500],
                "type": "cve",
                "platform": "multiple",
                "date_published": cve.get('published', '')[:10],
                "author": "NIST NVD",
                "verified": True
            })
    
    except Exception:
        pass
    
    return exploits
